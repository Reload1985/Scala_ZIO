1ï¸âƒ£ catchAll â†’ Capturar TODOS os erros

val catchError = anAttempt.catchAll(e => ZIO.attempt(s"Returning a different value because $e"))
ğŸ“Œ O que faz?

Se anAttempt falhar, captura qualquer erro (Throwable) e executa ZIO.attempt(...).
Aqui, estamos apenas retornando uma string explicando o erro.
âœ… Exemplo no Trello:
Se ao criar uma tarefa houver um erro (ex.: falha de conexÃ£o ao banco), podemos retornar uma mensagem amigÃ¡vel:

def createTask(task: Task): ZIO[Any, Throwable, String] =
  insertTaskIntoDB(task)
    .catchAll(_ => ZIO.succeed("Falha ao criar tarefa. Tente novamente."))


2ï¸âƒ£ catchSome â†’ Capturar ALGUNS erros especÃ­ficos

val catchSelectiveErrors = anAttempt.catchSome {
  case e: RuntimeException => ZIO.succeed(s"Ignoring runtime exceptions: $e")
  case _ => ZIO.succeed("Ignoring everything else")
}
ğŸ“Œ O que faz?

Filtra os erros por tipo.
Se for RuntimeException, retorna uma mensagem especÃ­fica.
Se for outro erro, ignora ou trata de forma diferente.
âœ… Exemplo no Trello:
Se houver um erro ao remover uma tarefa, mas queremos tratar apenas erros de tarefa inexistente (ex.: TaskNotFoundException), podemos fazer:


def removeTask(id: Int): ZIO[Any, Throwable, String] =
  deleteTaskFromDB(id).catchSome {
    case _: TaskNotFoundException => ZIO.succeed(s"A tarefa $id nÃ£o existe!")
  }
ğŸ”¹ Erros diferentes de TaskNotFoundException continuarÃ£o propagando.


3ï¸âƒ£ orElse â†’ Substituir o erro por um valor padrÃ£o

val aBetterAttempt = anAttempt.orElse(ZIO.succeed(56))
ğŸ“Œ O que faz?

Se anAttempt falhar, ele substitui pelo efeito ZIO.succeed(56).
âœ… Exemplo no Trello:
Se ao buscar uma tarefa, o banco de dados falhar, podemos fornecer uma tarefa padrÃ£o:

def getTask(id: Int): ZIO[Any, Throwable, Task] =
  fetchTaskFromDB(id).orElse(ZIO.succeed(Task(id, "Tarefa PadrÃ£o", "Sem descriÃ§Ã£o")))
ğŸ”¹ Evita que o sistema quebre se houver um erro inesperado.


4ï¸âƒ£ fold â†’ Lidar com SUCESSO e FALHA de forma sÃ­ncrona

val handleBoth: ZIO[Any, Nothing, String] = anAttempt.fold(
  ex => s"Something bad happened: $ex", 
  value => s"length of the string was $value"
)
ğŸ“Œ O que faz?

Se anAttempt falhar, executa ex => ....
Se anAttempt tiver sucesso, executa value => ....
âœ… Exemplo no Trello:
Se ao atribuir uma tarefa a um usuÃ¡rio ocorrer erro, podemos tratar assim:

def assignTask(taskId: Int, userId: Int): ZIO[Any, Nothing, String] =
  saveAssignment(taskId, userId).fold(
    ex => s"Falha ao atribuir tarefa: $ex",
    _ => s"Tarefa $taskId atribuÃ­da ao usuÃ¡rio $userId"
  )
ğŸ”¹ Garante que o sistema sempre retorna uma string, independente do sucesso ou erro.



5ï¸âƒ£ foldZIO â†’ Lidar com SUCESSO e FALHA de forma assÃ­ncrona

val handleBoth_v2 = anAttempt.foldZIO(
  ex => ZIO.succeed(s"Something bad happened: $ex"),
  value => ZIO.succeed(s"Length of the string was $value")
)
ğŸ“Œ O que faz?

Igual ao fold, MAS permite que os tratamentos retornem um efeito ZIO em vez de apenas valores simples.
âœ… Exemplo no Trello:
Se ao finalizar uma tarefa houver erro (ex.: banco de dados indisponÃ­vel), podemos salvar o erro num log:

def completeTask(taskId: Int): ZIO[Any, Nothing, String] =
  markTaskAsComplete(taskId).foldZIO(
    ex => logError(s"Erro ao completar tarefa $taskId: $ex").as("Erro ao completar tarefa"),
    _ => ZIO.succeed(s"Tarefa $taskId completada!")
  )
ğŸ”¹ Diferente do fold, foldZIO permite efeitos colaterais como logging.


ğŸ“Œ Quando usar cada um?
MÃ©todo    |	Quando usar?
catchAll  |	Quando quiser capturar qualquer erro e continuar. Ex.: Se falhar ao criar uma tarefa, retornar mensagem de erro.
catchSome |	Quando quiser capturar apenas alguns erros especÃ­ficos. Ex.: Ignorar erro de tarefa inexistente ao removÃª-la.
orElse    |	Quando quiser fornecer um valor padrÃ£o caso ocorra erro. Ex.: Retornar uma tarefa padrÃ£o se a busca falhar.
fold      |	Quando quiser transformar erro ou sucesso num valor simples (sem efeitos). Ex.: Retornar mensagem de sucesso ou erro ao atribuir tarefa.
foldZIO	  | Quando quiser tratar erro ou sucesso com efeitos colaterais. Ex.: Logar erro antes de retornar mensagem.

ğŸ“Œ Resumo
Esses mÃ©todos tornam o cÃ³digo mais seguro e previsÃ­vel.
Ãšteis para tratar erros em qualquer aÃ§Ã£o do sistema (criaÃ§Ã£o, atribuiÃ§Ã£o, remoÃ§Ã£o de tarefas).
Usar foldZIO para efeitos mais complexos, catchAll para capturar erros globais e orElse para valores padrÃ£o.


ğŸ“Œ Exemplo no Trello: Buscar uma tarefa por ID

val getTaskAttempt: ZIO[Any, Throwable, Task] = ZIO.attempt {
  println("Buscando a tarefa no banco de dados...")
  val task: Task = findTaskById(42) // Supondo que esta funÃ§Ã£o pode lanÃ§ar uma exceÃ§Ã£o
  if (task == null) throw new TaskNotFoundException("Tarefa nÃ£o encontrada")
  task
}
ğŸ“Œ O que acontece aqui?
Tentamos buscar uma tarefa no banco de dados (findTaskById).
Se findTaskById falhar (lanÃ§ar exceÃ§Ã£o), ZIO captura e trata como efeito falho.
Se a tarefa for null, lanÃ§amos uma exceÃ§Ã£o manualmente (throw new TaskNotFoundException(...)).


ğŸ“Œ Tratando possÃ­veis erros
Agora, podemos tratar esse erro de forma segura:

val safeGetTask = getTaskAttempt.catchAll {
  case _: TaskNotFoundException => ZIO.succeed(Task(0, "Tarefa PadrÃ£o", "Nenhuma descriÃ§Ã£o")) // Retorna uma tarefa padrÃ£o
  case ex => ZIO.fail(ex) // Se for outro erro, propaga
}
âœ… Se a tarefa nÃ£o for encontrada, retorna uma tarefa padrÃ£o.
âœ… Se for outro erro (ex.: erro de conexÃ£o com o banco), propaga o erro.


ğŸ“Œ Melhorando ainda mais
Podemos usar foldZIO para registrar logs antes de retornar uma resposta:

val safeGetTaskWithLogs = getTaskAttempt.foldZIO(
  ex => logError(s"Erro ao buscar tarefa: $ex").as(Task(0, "Erro", "NÃ£o foi possÃ­vel carregar a tarefa")),
  task => ZIO.succeed(task)
)
ğŸ”¹ Se falhar, loga o erro e retorna uma "tarefa de erro".
ğŸ”¹ Se tiver sucesso, simplesmente retorna a tarefa.

ğŸ“Œ ConclusÃ£o
ZIO.attempt Ã© Ãºtil para capturar exceÃ§Ãµes de cÃ³digo tradicional.
Em projetos tipo Trello, podemos usÃ¡-lo para acessar banco de dados, APIs, etc.
Combinar com catchAll, foldZIO, orElse melhora a seguranÃ§a e experiÃªncia do usuÃ¡rio.