O Que √© um Semaphore?
Pensa num semaphore como um controle de acesso que limita o n√∫mero de tarefas que podem fazer alguma coisa ao mesmo tempo.

üîë Como Funciona:
Imagina que tens 3 chaves para um banheiro p√∫blico. Se 3 pessoas estiverem l√° dentro:
Quem chegar depois espera at√© algu√©m sair e devolver uma chave.
Quando uma pessoa sai, libera uma chave e outra pode entrar.
No contexto de programa√ß√£o:
Um Semaphore controla o n√∫mero m√°ximo de tarefas que podem acessar um recurso cr√≠tico ao mesmo tempo.
Se n√£o houver permiss√£o dispon√≠vel, as outras esperam.
Por Que Usar Semaphore?
Controlar Acesso Concorrente: Garantir que apenas X tarefas executem uma a√ß√£o ao mesmo tempo.
Evitar Sobrecarga: Controlar o uso de recursos (ex.: acesso a uma API limitada a X requisi√ß√µes por segundo).
Coordenar Tarefas: Garantir que algumas tarefas esperem enquanto outras concluem suas opera√ß√µes cr√≠ticas.
Quando Usar?
Quando precisas limitar o acesso a um recurso partilhado.
Exemplo:
Apenas 2 utilizadores podem editar um quadro do Trello ao mesmo tempo para evitar conflitos.
Exemplo no Trello:
Imagina que tens uma funcionalidade no Trello onde:

M√°ximo 2 utilizadores podem editar a mesma lista de tarefas ao mesmo tempo.
Se houver 3 ou mais, eles devem esperar.
Vamos ao C√≥digo!
scala
Copy
Edit
import zio._
import zio.duration._

object TrelloSemaphoreExample extends ZIOAppDefault {

  // Simula a edi√ß√£o de uma lista de tarefas
  def editList(listId: Int): UIO[Int] = for {
    _ <- ZIO.succeed(s"[List $listId] Editing...").debugThread
    _ <- ZIO.sleep(2.seconds) // Simula o tempo de edi√ß√£o
    _ <- ZIO.succeed(s"[List $listId] Edit completed!").debugThread
  } yield listId

  // O Semaphore para limitar a edi√ß√£o a no m√°ximo 2 utilizadores
  val semaphoreExample = for {
    sem <- Semaphore.make(2) // M√°ximo de 2 permiss√µes
    results <- ZIO.collectAllPar((1 to 5).map { listId =>
      sem.withPermit {
        editList(listId)
      }
    })
  } yield results

  def run = semaphoreExample.debugThread
}
üîç O Que Acontece Aqui?
Semaphore.make(2) cria um Semaphore com 2 permiss√µes:
No m√°ximo 2 tasks podem editar ao mesmo tempo.
.withPermit:
Cada editList(listId) precisa de uma permiss√£o para come√ßar.
Se j√° houver 2 permiss√µes em uso, a task espera.
collectAllPar:
Executa todas as edi√ß√µes em paralelo, mas respeitando o limite do Semaphore.
debugThread:
Imprime na consola em que thread a task est√° a correr, para ver o paralelismo em a√ß√£o.
O Que Vais Ver na Consola?
Apenas 2 listas est√£o a ser editadas ao mesmo tempo.
As outras esperam at√© que uma edi√ß√£o seja conclu√≠da.
Exemplo:

csharp
Copy
Edit
[List 1] Editing...
[List 2] Editing...
[List 1] Edit completed!
[List 3] Editing...
[List 2] Edit completed!
[List 4] Editing...
[List 3] Edit completed!
[List 5] Editing...
[List 4] Edit completed!
[List 5] Edit completed!
Fun√ß√µes Mais Usadas:
Semaphore.make(n: Long): Cria um Semaphore com n permiss√µes.
.withPermit(effect: ZIO): Executa o efeito se houver uma permiss√£o dispon√≠vel, caso contr√°rio, espera.
.withPermits(n: Long): Requer n permiss√µes para continuar.
Vantagens:
Controle Preciso: Controla exatamente quantas tarefas podem aceder a um recurso cr√≠tico.
Evita Conflitos: No Trello, evita que m√∫ltiplos utilizadores editem ao mesmo tempo, prevenindo conflitos de dados.
Melhor Desempenho: Coordena tarefas em paralelo, aproveitando o m√°ximo de recursos sem sobrecarga.
Resumo:
Semaphore √© um controle de acesso que limita quantas tasks podem rodar ao mesmo tempo.
Ideal para coordenar acessos a recursos partilhados.
No Trello, controla o n√∫mero de utilizadores a editar ao mesmo tempo.
withPermit √© a chave para garantir o acesso controlado.
Ajuda a evitar conflitos e melhorar o desempenho.
