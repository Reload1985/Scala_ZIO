O que sÃ£o os aliases do ZIO?
Os aliases (UIO, RIO, URIO, etc.) sÃ£o apenas versÃµes especializadas do ZIO que removem parÃ¢metros desnecessÃ¡rios.

Lembra que um efeito ZIO[R, E, A] tem 3 partes:

R â†’ DependÃªncias necessÃ¡rias (ex.: conexÃ£o com DB).
E â†’ Tipo do erro que pode ocorrer.
A â†’ Tipo do valor de retorno.
Quando algumas dessas partes nÃ£o sÃ£o necessÃ¡rias, usamos aliases!

--------------------------------------------------------  !!!!!!! --------------------------------------------------------

Principais Aliases do ZIO

Alias       |	Equivalente a ZIO[R, E, A]  |	O que significa?

UIO[A]      |	ZIO[Any, Nothing, A]        |	Efeito sem falha garantida (nunca dÃ¡ erro).
RIO[R, A]   |	ZIO[R, Throwable, A]        |	Efeito que pode falhar, mas requer R (ex.: DB).
URIO[R, A]  |	ZIO[R, Nothing, A]          |	Requer R (ex.: DB), mas nunca falha.
Task[A]     |	ZIO[Any, Throwable, A]      |	Efeito que pode falhar com Throwable, mas nÃ£o precisa de R.


AplicaÃ§Ã£o prÃ¡tica no sistema de tarefas
Imagina que temos um serviÃ§o que:

Cria uma tarefa no DB.
Busca uma tarefa.
Marca uma tarefa como concluÃ­da.
Agora vamos usar os aliases corretamente!

1ï¸âƒ£ Criar uma tarefa (sem falha garantida) â†’ UIO[Task]

    import zio.*

    case class Task(id: Int, description: String, completed: Boolean)

    object TaskService {
    def createTask(description: String): UIO[Task] =
        ZIO.succeed(Task(1, description, completed = false)) // Nunca falha
    }
Por que UIO?

NÃ£o depende de nada (Any).
NÃ£o pode falhar (Nothing).
Retorna uma Task.

2ï¸âƒ£ Buscar uma tarefa do DB (pode falhar) â†’ RIO[Database, Task]

trait Database {
  def fetchTask(id: Int): Task
}

object TaskService {
  def getTask(id: Int): RIO[Database, Task] =
    ZIO.serviceWithZIO[Database](_.fetchTask(id))
}
Por que RIO[Database, Task]?

Requer uma Database para funcionar (R = Database).
Pode falhar (E = Throwable).
Retorna uma Task.

3ï¸âƒ£ Marcar uma tarefa como concluÃ­da (nÃ£o falha, mas precisa do DB) â†’ URIO[Database, Unit]

object TaskService {
  def completeTask(id: Int): URIO[Database, Unit] =
    ZIO.serviceWithZIO[Database] { db =>
      ZIO.succeed(println(s"Tarefa $id concluÃ­da!"))
    }
}
Por que URIO[Database, Unit]?

Requer Database (R = Database).
Nunca falha (E = Nothing).
Retorna Unit (efeito sem retorno Ãºtil).


ğŸ“Œ Resumo prÃ¡tico
MÃ©todo                    |	    Alias               |	Por quÃª?
createTask(desc: String)  |	    UIO[Task]           |	Criar tarefa nunca falha.
getTask(id: Int)          |	RIO[Database, Task]     |	Buscar tarefa pode falhar e requer DB.
completeTask(id: Int)     |	URIO[Database, Unit]    |	Atualizar tarefa requer DB, mas nunca falha.


ğŸ“Œ ConclusÃ£o
Usa UIO[A] quando nunca hÃ¡ falha.
Usa RIO[R, A] quando hÃ¡ falha e precisa de dependÃªncias.
Usa URIO[R, A] quando precisa de dependÃªncias mas nunca falha.
Usa Task[A] quando pode falhar mas nÃ£o precisa de dependÃªncias.
